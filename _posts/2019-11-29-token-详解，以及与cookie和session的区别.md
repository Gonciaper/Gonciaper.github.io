---
permalink: /posts/new11
display: normal
title: Token 详解，以及与Cookie和Session的区别
tags: web
date: '2017-05-16 20:39:00 +08:00'
comment: true
layout: post
component: web
---
### 什么是 JWT ?

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。

JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。

**基于 Token 的身份验证**

基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便

**大概的流程是这样的：**

客户端使用用户名跟密码请求登录

服务端收到请求，去验证用户名与密码

验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端

客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里

客户端每次向服务端请求资源的时候需要带着服务端签发的 Token

服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

APP 登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成 32 位的字符串作为 token，存储到服务器中，并返回 token 到 APP，以后 APP 请求时，凡是需要验证的地方都要带上该 token，然后服务器端验证 token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上 token 设置一个有效期，每次 APP 请求的时候都验证 token 和有效期。

**那么我的问题来了：** 
1. 服务器上的 token 存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢。

2. 客户端得到的 token 肯定要加密存储的，发送 token 的时候再解密。存储到数据库还是配置文件呢？

token 是个易失数据，丢了无非让用户重新登录一下，新浪微博动不动就让我重新登录，反正这事儿我是无所谓啦。

所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说 mysql 的内存表性能提升有限），可以放到 Memcache 里（讲真，这个是挺常见的策略），可以放到 redis 里（我做过这样的实现），甚至可以放到 OpenResty 的变量字典里（只要你有信心不爆内存）。

token 是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token 丢了重新操作下认证一个就可以了，因此 token 丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。

基于这个出发点，如果你认为用数据库来保持 token 查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。

**比如 memcached、redis，KV 方式很适合你对 token 查询的需求。**

这个不会太占内存，比如你的 token 是 32 位字符串，要是你的用户量在百万级或者千万级，那才多少内存。

要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个 token 生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。

客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那 token 肯定会存在泄露的问题。比如我拿到你的手机，把你的 token 拷出来，在过期之前就都可以以你的身份在别的地方登录。

**解决这个问题的一个简单办法**

1、在存储的时候把 token 进行对称加密存储，用时解开。

2、将请求 URL、时间戳、token 三者进行合并加盐签名，服务端校验有效性。

这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序 hack 你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储……

方法 1 它拿到存储的密文解不开

方法 2 它不知道你的签名算法和盐，两者可以结合食用。

但是如果 token 被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。

于是可以提供一个让用户可以主动 expire 一个过去的 token 类似的机制，在被盗的时候能远程止损。

在网络层面上 token 明文传输的话会非常的危险，所以建议一定要使用 HTTPS，并且把 token 放在 post body 里。

**session**

session 的中文翻译是 “会话”，当用户打开某个 web 应用时，便与 web 服务器产生一次 session。服务器使用 session 把用户的信息临时保存在了服务器上，用户离开网站后 session 会被销毁。这种用户信息存储方式相对 cookie 来说更安全，可是 session 有一个缺陷：如果 web 服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 session 会丢失。

**cookie**

cookie 是保存在本地终端的数据。cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie 发送给服务器。由于 cookie 是存在客户端上的，所以浏览器加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 数量是有限的。

cookie 的组成有：名称 (key)、值 (value)、有效域 (domain)、路径 (域的路径，一般设置为全局:”\”)、失效时间、安全标志 (指定后，cookie 只有在使用 SSL 连接时才发送到服务器 (https)

**token**

token 的意思是 “令牌”，是用户身份的验证方式，最简单的 token 组成: uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由 token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接 token 请求服务器)。还可以把不变的参数也放进 token，避免多次查库

### cookie 和 session 的区别

1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。

2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗

考虑到安全应当使用 session。

3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

考虑到减轻服务器性能方面，应当使用 COOKIE。

4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

5、所以个人建议：

将登陆信息等重要信息存放为 SESSION

其他信息如果需要保留，可以放在 COOKIE 中

### token 和 session 的区别

session 和 oauth token 并不矛盾，作为身份认证 token 安全性比 session 好，因为每个请求都有签名还能防止监听以及重放攻击，而 session 就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态

token 就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie 就是写在客户端的一个 txt 文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用 cookie 自动登录用户名；session 和 cookie 差不多，只是 session 是写在服务器端的文件，也需要在客户端写入 cookie 文件，但是文件里是你的浏览器编号. Session 的状态是存储在服务器端，客户端只有 session id；而 Token 的状态是存储在客户端。
